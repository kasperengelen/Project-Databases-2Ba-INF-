DataTransformer guide

DE CONSTRUCTOR:

neemt de user.id, setid, db_connection, SQLAlchemy engine en een optional argument "replace"
"replace" op False zetten zorgt ervoor dat een transformatie een nieuwe table creëert.
replace staat standaard op True, dit betekent dat niets specifiëren ervoor zorgt dat
de gegeven table wordt aangepast, dus een soort "overwrite".

DataTransformer(userid, setid, db_connection, engine, replace=True) => Zal de table overwriten

DataTransformer(userid, setid, db_connection, engine, False) => Zal een nieuwe table maken en de originele onveranderd laten

----------------------------------------------------------------------------------

#############################################
# delete_attribute(tablename, attribute, new_name=""):
#############################################
(REEDS GEÏMPLEMENTEERD EN VANZELFSPREKEND)


-----------------------------------------------------------------------------------

#############################################
# find_and_replace(tablename, attribute, value, replacement, exact=True, replace_all=True, new_name="")
#############################################

(AANGEPAST!!!)

Zelfde functionaliteit als vorige versie maar extra boolean fields voor een beetje andere behaviour.

exact is een boolean dat indiceert of de string whole-words moet matchen of niet.
	True zal alleen "appel" = "appel" replacen. (een exacte match)
	False zal ook substrings kunnen vinden dus "appelboom" wordt gevonden met de search voor "appel"

replace_all is een boolean om de replace behaviour in het gevan van een substring find and replace te bepalen
	True zal heel de string vervangen dus find and replace ("appel", "kiwi") zal "appelboom" vervangen door "kiwi"
	False zal enkel de substring vervangen dus find and replace ("appel", "kiwi") zal "appelboom" vervangen door "kiwiboom"

------------------------------------------------------------------------------------
#############################################
# regex_find_and_replace(self, tablename, attribute, regex, replacement, case_sens=False, new_name="")
#############################################

Redelijk gelijkaardig aan find_and_replace

regex is dus gewoon de reguliere expressie die de user meegeeft (POSIX regex)

replacement is vervang waarde (voor deze method is geen substring vervanging, heel de match wordt vervangen door replacement)

case_sens is een boolean die de optie geeft om case sensitive te werken of niet.



------------------------------------------------------------------------------------

#############################################
# get_conversion_options(self, tablename, attribute):
#############################################

Deze method returnt een lijst van alle mogelijke conversies voor een attribuut dat ondersteunt wordt door
DataTransformer. De parameters zijn vrij duidelijk.

------------------------------------------------------------------------------------

#############################################
# change_attribute_type(tablename, attribute, to_type, data_format="", new_name=""):
#############################################

Deze method converteert een attribuut naar een andere type.
setname, tablename, attribute zijn van vanzelfsprekend. to_type is een string die de POSTGRES type accepteert.
data_format is een parameter die voor speciale conversies geldt, ik moet deze nog implementeren dus negeer deze.
new_name is wederom zoals de vorige functies een parameter die de naam is van de nieuwe tabel die gemaakt wordt
indien replace op False staat. 

Let op, als je een nieuwe tabel wil maken en tegelijk data_format wilt negeren dan moet je niet vergeten
expliciet data_format op "" te zetten, anders zal new_name leeg blijven en de meegegeven new_name bij data_formaat gegeven worden.

Mijn persoonlijke mening is om deze functie zodanig te gebruiken bij de front-end: wanneer iemand een attribuut wilt converteren kan je
best get_conversion_options() callen en zo alle opties weergeven voor de gebruiker. De keuze van de gebruiker dan gebruiken als to_type
en de conversie uitvoeren.


-------------------------------------------------------------------------------------

#############################################
# one_hot_encode(tablename, attribute, new_name="")
#############################################

Deze method voert one-hot-encoding uit op een table.
De parameters zijn vanzelfsprekend. new_name enkel assignen
in het geval dat replace op false is. Maar het zou geen effect hebben ookal vul je het wel in zonder replace op False te zetten.
Front-end implementatie is evident.

--------------------------------------------------------------------------------------

#############################################
# normalize_using_zscore(tablename, attribute, new_name="")
#############################################

Deze method normaliseert alle waarde van een kolom in range [0, 1].
Dit werkt alleen maar op numerieke waardes. Een call op een niet numerieke waarde raiset een custom
exception, maar daar zullen we samen nog voor samenzitten.
Front-end implementatie is evident.


--------------------------------------------------------------------------------------

#############################################
# discretizise_using_equal_width(tablename, attribute, new_name="")
#############################################

Deze method discretiseert in equi-distant intervallen zoals in een histogram.
Dit werkt alleen maar op numerieke waardes. Een call op een niet numerieke waarde raiset een custom
exception, maar wederom zal dit later pas besproken worden.
Front-end implementatie is evident.

--------------------------------------------------------------------------------------

#############################################
# discretizise_using_equal_frequency(tablename, attribute, new_name="")
#############################################

Deze method discretiseert in equi-frequent intervallen zoals in een histogram.
Dit werkt alleen maar op numerieke waardes. Een call op een niet numerieke waarde raiset een custom
exception, maar wederom zal dit later pas besproken worden.
Front-end implementatie is evident.

--------------------------------------------------------------------------------------

#############################################
# discretizise_using_custom_ranges(tablename, attribute, ranges, exclude_right=True, new_name="")
#############################################

Deze method discretiseert in intervallen die gegeven zijn door de gebruiker. De front-end implementatie is dus niet
evident. Er moet vanuit de front-end op een of andere manier de mogelijkheid gegeven worden om de gebruiker een lijst
van integers / floats te laten beschrijven die dan de edges van de intervals worden. Dit zou op een zoveel mogelijk
ge-sandboxte manier gebeuren zodat er geen vreemde dingen gebeuren.

parameter ranges is dan een python list die de edges beschrijft. Bv ranges zou dan [0, 10, 20, 30] kunnen zijn
en dan zal de method discretiseren met als intervallen [0 - 10[, [10 - 20[, [20 - 30[.
Er moet ook een field zijn die bepaalt of een interval half open is naar rechts (zoals hierboven) of half open naar links
zoals ]0 - 10], ]10, 20], etc. Dit is de exclude_right parameter.
True geeft intervallen als het eerste voorbeeld en False geeft intervallen als het laatste voorbeeld.

---------------------------------------------------------------------------------------

#############################################
# delete_outlier(self, tablename, attribute, larger, value, new_name="")
#############################################

Deze method zet outliers op null. Deze keuze werd tactisch gemaakt omdat dan de gebruiker
via andere methods (die later beschreven worden) die null values kunnen vervangen door
de mediaan, het gemiddelde of zelfs een custom value naar keuze.

Deze transformatie is vrij simpel te implementeren in front-end. larger is een boolean die laat
weten of de outliers kleiner of groter moeten zijn dan value. True is alles groter dan value wordt op nul gezet,
False is alles kleiner wordt op null gezet.

Value is natuurlijk de waarde die als comparison gebruikt wordt om de outliers te identifiëren.

----------------------------------------------------------------------------------------

#############################################
# fill_nulls_with_mean(tablename, attribute, new_name="")
#############################################

Deze method vult alle nulls in een attribute met het gemiddelde.
Front-end implementatie is evident.


-----------------------------------------------------------------------------------------

#############################################
# fill_nulls_with_median(tablename, attribute, new_name="")
#############################################

Deze method vult alle nulls in een attribute met de mediaan.
Front-end implementatie is evident.

-----------------------------------------------------------------------------------------

#############################################
# fill_nulls_with_custom_value(tablename, attribute, new_name="")
#############################################

Deze method vult alle nulls in een attribute met de gegeven waarde.
Front-end implementatie is evident.


 


